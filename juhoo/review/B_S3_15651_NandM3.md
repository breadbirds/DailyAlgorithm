# 백준 15651 N과 M (3) | 실버 3 | StringBuilder

[🏁 문제 바로가기](https://www.acmicpc.net/problem/15651)

### My Code
```java
package source_code;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;

public class B_S3_NandM3 {
	static int N;
	static int M;
	static List<Integer> numList;
	static StringBuilder sb;

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String s = br.readLine();

		sb = new StringBuilder();

		N = Integer.parseInt(s.split(" ")[0]);
		M = Integer.parseInt(s.split(" ")[1]);
		numList = new ArrayList<>();

		findSequence(0);

		System.out.println(sb);

	}

	private static void findSequence(int depth) {
		if (depth == M) {
			for (int i = 0; i < M; i++) {
				sb.append(numList.get(i));

				if (i != M - 1) {
					sb.append(" ");
				}
			}
			sb.append("\n");
			return;
		}

		for (int i = 1; i <= N; i++) {
			numList.add(i);

			findSequence(depth + 1);

			numList.remove(numList.size() - 1);
		}

	}
}

```

기존 코드에서는 depth가 M 과 같아지면 그때마다 출력하도록 했는데, 시간초과로 실패했다.
그래서 StringBuilder를 활용해서 저장하고, 한 번에 출력하는 방식으로 수정했더니 통과되었다.

그런 의미에서 복습해보는 StringBuilder!

### StringBuilder
문자열을 효율적으로 수정할 수 있도록 만든 Java 클래스.
기본 String과의 가장 큰 차이: **`불변(immutable)이 아니라는 것!`**

#### StringBuilder 왜 필요할까?
- String은 불변 -> 문자열을 수정하면 **새로운 객체를 계속 생성**함 -> **메모리 낭비 + 속도 저하**

- StringBuilder는 내부적으로 동일한 버퍼를 재사용해서, 문자열 변경 시 매번 객체를 반들지 않음 => 속도 빠름!

#### 기본 사용법
```java
StringBuilder sb = new StringBuilder("Hello");

// 추가
sb.append(" World");  // "Hello World"

// 삽입
sb.insert(5, " Java"); // "Hello Java World"

// 수정
sb.replace(6, 10, "Kotlin"); // "Hello Kotlin World"

// 삭제
sb.delete(6, 13); // "Hello World"

// 뒤집기
sb.reverse(); // "dlroW olleH"

// 길이 확인
int len = sb.length();

```

#### 특징
| 특징     | 내용                                                             |
| ------ | -------------------------------------------------------------- |
| 가변성    | 내용 변경 시 새로운 객체를 만들지 않음                                         |
| 동기화 여부 | **StringBuilder**: 비동기(빠름), **StringBuffer**: 동기화 지원(멀티스레드 안전) |
| 초기 용량  | 기본 16 문자 공간, 넘치면 자동 확장                                         |
| 성능     | 반복 문자열 연결 시 `String`보다 훨씬 빠름                                   |

#### 언제 쓰는가?
- 루프에서 문자열을 반복 연결할 때
- 대량 문자열 편집이 필요한 경우
- 멀티스레드가 아니라면 StringBuffer보다 StringBuilder 사용 (성능 up)
