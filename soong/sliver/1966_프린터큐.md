
# [백준- S3] 1966. 프린터 큐

## ⏰  **time**
60분

## :pushpin: **Algorithm**
Deque

1. 각 문서의 인덱스(`idx`)와 우선순위(`priority`)를 `Doc` 객체로 만들어 `Deque`에 삽입한다.
2. 큐에서 맨 앞의 문서(cur)를 꺼낸다.
3. 현재 문서보다 우선순위가 높은 문서가 큐에 존재하는지 검사한다.
    - 있다면 → 현재 문서를 다시 큐의 맨 뒤로 보낸다.
    - 없다면 → 현재 문서를 실제로 출력한다.
4. 문서를 출력할 때마다 `cnt++` 한다.
5. 만약 방금 출력된 문서의 `idx`가 찾고 있는 문서의 인덱스(`M`)라면 
    → 현재 `cnt`가 정답이므로 출력하고 종료한다.

```java
public class Main {

	static class Doc {
		int idx;
		int priority;

		Doc(int idx, int priority) {
			this.idx = idx;
			this.priority = priority;
		}
	}

	public static void main(String[] args) throws Exception {

		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int T = Integer.parseInt(br.readLine());

		for (int t = 0; t < T; t++) {

			String[] split = br.readLine().split(" ");
			int N = Integer.parseInt(split[0]);
			int M = Integer.parseInt(split[1]);

			split = br.readLine().split(" ");
			Deque<Doc> deque = new ArrayDeque<Doc>();
			for (int i = 0; i < N; i++) {
				deque.offer(new Doc(i, Integer.parseInt(split[i])));
			}

			int cnt = 0;
			while (!deque.isEmpty()) {

				Doc cur = deque.poll();

				boolean hasHigher = false;
				for (Doc d : deque) {
					if (d.priority > cur.priority) {
						hasHigher = true;
						break;
					}
				}

				if (hasHigher) {
					deque.offer(cur);
				} else {
					cnt++;
					if (cur.idx == M) {
						System.out.println(cnt);
						break;
					}
				}
			}

		}

	}

}
```

## :black_nib: **Review**
앞에서 뽑아서 뒤에 삽입하기 위해 Deque를 사용

## 📡**Link**
- https://www.acmicpc.net/problem/1966

