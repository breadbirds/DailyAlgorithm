

# [백준 - G2] 4195. 친구 네트워크

## 왜 Union-Find를 사용해야 하는 가?
1. 서로소 집합(그룹/네트워크) 문제일 때
    - 합치기나 대표 찾기가 필요할 때
2. 두 원소가 같은 집합인지 확인 할 때
3. 그룹 크기/정보를 빠르게 관리해야 할 때
    - 친구 네트워크 문제처럼 매번 그룹 전체 크기를 출력해야 하는 경우,
    - DFS/BFS로 매번 세면 $O(N^2)$ → 시간초과
    - 대신 DSU에서 대표 노드에 `size`를 저장하면, 합칠 때만 갱신하므로 $O(1)$에 그룹 크기를 알 수 있음.

4. 입력 크기가 크다 (예: 10만 이상)
    - DFS/BFS로 매번 전체 탐색은 불가능 (시간초과 확정)
    - 하지만 Union-Find는 $O(α(N))$ (거의 상수 시간)
    - 대량의 union/find 쿼리를 효율적으로 처리하는 구조라는 점에서 떠올려야 함.

## 틀린 코드

- 친구 네트워크래서 DFS로 풀이했는데
- **매번 DFS로 네트워크 전체를 다시 세고 있기 때문에** 시간초과가 발생했다.

<details>
    <summary>틀린 코드</summary>

    class Solution {

        static HashMap<String, Integer> hash;

        public static void main(String[] args) throws Exception {
            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
            String input = br.readLine();

            int T = Integer.parseInt(input);
            for (int t = 0; t < T; t++) {
                int F = Integer.parseInt(br.readLine());

                hash = new HashMap<>();
                graph = new ArrayList[2 * F];

                for (int i = 0; i < graph.length; i++) {
                    graph[i] = new ArrayList<>();
                }

                for (int i = 0; i < F; i++) {
                    String[] split = br.readLine().split(" ");
                    for (int j = 0; j < split.length; j++) {
                        // 친구 그래프에 아직 없을 경우, 추가
                        if (!hash.containsKey(split[j])) {
                            int size = hash.size();
                            hash.put(split[j], size++);
                        }

                    }

                    connect(split[0], split[1]);

                }
            }

        }

        static List<Integer>[] graph;
        static boolean[] visited;
        static int cnt;
        static void connect(String friend1, String friend2) {

            int idx1 = hash.get(friend1);
            int idx2 = hash.get(friend2);

            graph[idx1].add(idx2);
            graph[idx2].add(idx1);

            visited = new boolean[graph.length + 1];

            // System.out.println(hash);
            // System.out.println(Arrays.toString(graph));
            cnt = 1;
            countNetwork(idx1);		
            System.out.println(cnt);
            
        }

        static void countNetwork(int v) {

            visited[v] = true;

            for (int next : graph[v]) {
                if (!visited[next]) {
                    visited[next] = true;
                    countNetwork(next);
                    cnt++;
                }
            }

        }
    }

</details>


## 정답 코드

1. 두 사람의 `root`를 비교해, 서로 다를 경우 둘을 합친다.
2. `size[a] < size[b]`일 경우 , 항상 `a`가 대표가 되게 하기 위해 둘의 값을 바꾼다.
3. 만약, swap을 하지 않으려면, 그때 그때 누가 대표가 될지 명시적으로 처리한다.
    ```java
    if (size[a] < size[b]) {
        parent[a] = b;       // 작은 집합(a)을 큰 집합(b)에 붙임
        size[b] += size[a];  // b가 대표니까 b의 크기를 갱신
        return size[b];
    } else {
        parent[b] = a;       // 작은 집합(b)을 큰 집합(a)에 붙임
        size[a] += size[b];  // a가 대표니까 a의 크기를 갱신
        return size[a];
    }
    ```


```java
class Solution {

	static HashMap<String, Integer> hash;
	static int[] parent, size;

	public static void main(String[] args) throws Exception {

		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String input = br.readLine();

		int T = Integer.parseInt(input);
		for (int t = 0; t < T; t++) {
			int F = Integer.parseInt(br.readLine());

			hash = new HashMap<>();
			parent = new int[2 * F];
			size = new int[2 * F];

			for (int i = 0; i < parent.length; i++) {
				parent[i] = i;
				size[i] = 1;
			}

			int idx = 0;
			for (int i = 0; i < F; i++) {
				String[] split = br.readLine().split(" ");
				for (int j = 0; j < split.length; j++) {

					// 친구 그래프에 아직 없을 경우, 추가
					if (!hash.containsKey(split[j])) {
						hash.put(split[j], idx++);
					}

				}

				int a = hash.get(split[0]);
				int b = hash.get(split[1]);

				// 네트워크 합치기
				System.out.println(union(a, b));

			}
		}

	}

	static int find(int u) {
		if (parent[u] != u) {
			parent[u] = find(parent[u]);
		}

		return parent[u];
	}

	static int union(int a, int b) {

		a = find(a);
		b = find(b);

		if (a != b) {

			// 항상 큰 쪽을 대표로 삼음
			if (size[a] < size[b]) {
				int tmp = a;
				a = b;
				b = tmp;
			}

			parent[b] = a;
			size[a] += size[b];
		}

		return size[a];
	}

}
```

## 문제 링크
- https://www.acmicpc.net/problem/4195